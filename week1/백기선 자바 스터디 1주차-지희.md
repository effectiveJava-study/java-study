## 목표

자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기.

## 학습할 것

- **JVM이란 무엇인가**
    
    자바 가상 머신으로 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할
    
- **컴파일 하는 방법**
    1. 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환
    2. Class Loader를 통해 class 파일들을 JVM으로 로딩
    3. 로딩된 class파일들은 Execution engine을 통해 해석
    4. 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어진다.
        
        ![153544558-dc69f626-d914-49ae-a5ae-1782ee610305.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dc7c487e-c16e-4cb8-b11c-d92c6cbec110/153544558-dc69f626-d914-49ae-a5ae-1782ee610305.png)
        
    
- **실행하는 방법**
    
    
- **바이트코드란 무엇인가**
    
    중간코드 라고도 불림.
    JVM 이 읽을 수 있는 언어
    
    **바이트 코드가 할 수 있는 것**
    
    프로그램 분석
    
    클래스 파일 생성
    
- **JIT 컴파일러란 무엇이며 어떻게 동작하는지**
    
    JVM처럼 실행 시점에 그때그때 기계어로 '통번역'을 해주는 방식. Just In Time 컴파일, 줄여서 JIT컴파일.
    
    ![img1.daumcdn.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fafa0aa8-821f-4d57-8a5f-c820b81fe006/img1.daumcdn.png)
    
    ![img1.daumcdn.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee3ddad2-66d7-4209-acb0-e214471fcc68/img1.daumcdn.png)
    
- **JVM 구성 요소**
    
    JVM의 구조는 크게 클래스로더(Class Loader), 메모리(Jvm Memory), 실행 엔진(Execution Engine) 으로 구성.
    
    ![img1.daumcdn.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2ed1bd6e-3636-4b8a-a151-466adefdcc95/img1.daumcdn.png)
    
    ### **(1) Class Loader**
    
    JVM 내로 클래스 파일을 로드하고,링크를 통해 배치하는 작업을 수행하는 모듈.런타임 시에 동적으로 클래스를 로드(로딩 -> 링크 -> 초기화 순으로 진행).
    
    ### **(2)** Jvm Memory
    
    **(1)힙**
    
    힙은 인스턴스화 된 모든 클래스 인스턴스와 배열, 객체를 저장.
    모든 JVM 스레드에 공유 되는 공유 자원.
    힙에 저장된 할당된 메모리 회수 권한은 무조건 가비지 컬렉터(Garbage Collector)에 의해서만 회수가 가능.
    
    **(2)메소드**
    
    메서드 영역에서는 런타임 상수풀, 필드와 메소드 데이터 내용, 즉 클래스 수준의 정보를 저장하게 된다.
    
    그림에서는 힙과 메서드 영역을 분리하였지만, jvm 스펙에서는 메소드 영역이 논리적으로 힙의 일부여서 가비지 컬렉션에 대상이 된다고 하지만, 강제적으로 메소드의 영역의 위치에 대해서 논하지 않는다고 한다. 즉, JVM 을 회사를 만드는 회사마다, 저 그림은 상이할 수 있다는 얘기다.
    
    **(3)PC 레지스터**
    
    PC레지스터는 현재 실행중인 메서드가 네이티브가 아니면, 현재 실행중인 JVM 명령어 위치에 저장되고, 네이티브이면 Pc 레지스터에 저장되는 값은 정의되지 않는다.CPU의 Register와는 다르게,  연산을 위해 필요한 피연산자를 임시로 저장하기 위한 용도로 사용한다.
    
    **(4)스택 (JVM Stack이라고도 불린다.)**
    
    LIFO동작으로 동작하는 자료구조 로써, 쓰레드 마다 런타임 스택을 만들고, JVM 스택에는 프레임에 저장된다. 메서드 하나가 호출될 때마다 새 프레임이 생성되어 스택에 쌓이고, 메서드 호출이 정상 완료되거나 예외가 던져지면 프레임은 스택에서 빠지면서 소멸된다. 또한 쓰레드가 종료되면 스택도 제거된다.
    
    **(5)네이티브 메소드 스택(Native Method stack)**
    
    네이티브 메서드 스택은 JVM의 스택이 아니라 C 스택을 가르킨다. 자바가 아닌 다른 언어로 작성된 네이티브 메서드를 지원하기 위해 사용되는 스택이다. 네이티브 메소드 스택은 JVM 스택과 마찬가지로 스레드 단위의 자료구조 이다.
    
    ### **(3)** Execution Engine
    
    클래스 로딩 과정을 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행
    이 과정을 수행하고 기계가 읽을수 있는 코드로 변경을 해주는데, 이때 사용되는게 인터프리터와 JIT컴파일러
    
- **JDK와 JRE의 차이**
    
    **JDK**
    
    자바 프로그램을 작성하고, JRE를 실행하는데 필요한 툴 들을 가지고 있음.
    
    컴파일러와 자바어플리케이션 런처, Appletiviewer등을 포함하고 있음.
    
    **JRE**
    
    클래스 라이브러리, JVM, 여러 Supporting 파일들을 가지고 있음.
    
    Debuger와 Compiler과 같은 개발 도구는 포함되어있지 않아서 JRE는 소스코드를 읽기 위해, JDK는 소스코드를 작성하기 위한 것들이 포함.
    
    | JDK | JRE | JVM |
    | --- | --- | --- |
    | jdk는 개발자 키트로, 개발에 필요한 어플리케이션 소프트웨어이다. | 소프트웨어 번들로, jre는 자바 클래스와 라이브러리, 필수적인 컴포넌트들을 제공한다. | jvm은 바이트코드를 실행하고, 실행에 필요한 환경을 제공한다. |
    | jdk는 플랫폼에 독립적이다. | jre는 플랫폼에 독립적이다. | jvm은 플랫폼에 종속적이다. |
