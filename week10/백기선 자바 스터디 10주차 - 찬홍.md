## Thread 클래스 VS Runnable 인터페이스

### 쓰레드를 생성하는 방법

1. Thread 클래스 사용
2. Runnable 인터페이스 사용
- Thread  클래스는 Runnable 인터페이스를 구현한 클래스
- `run()` 구현 부를 채우는 작업

```java
public interface Runnable {        
	public abstract void run();    
}
```

### Thread 선언 예

```java
class MyThread extends Thread {    
	@Override    
	public void run() { ... } // Thread 클래스의 run()을 오버라이딩
}
```

```java
class MyThread implements Runnable {    
	public void run() { ... } // Runnable 인터페이스의 run()을 구현
}
```

- `Thread` 클래스를 상속 받으면 다른 클래스를 상속 받을 수 없음.

### Thread 구현 예

```java
ThreadOne t1 = new ThreadOne();   // Thread의 자손 클래스의 인스턴스를 생성

Runnable r = new ThreadTwo();     // Runnable을 구현한 클래스의 인스턴스를 생성
Thread t2 = new Thread(r);        // 생성자 Thread(Runnable Target)

class ThreadOne extends Thread {

    @Override
    public void run() {···}
}
```

### Thread의 실행

- 쓰레드를 생성하였다고 해서 자동으로 실행 되는 것이 아니다. 
→ `start()` 메소드를 호출해야 한다.
- `start()` 메소드가 호출 되었다고 해서 바로 실행 되는 것이 아니다.
→ 실행 대기 상태에 있다가 차례가 되면 실행 된다.
- 한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다. 
→하나의 쓰레드에 대해 `start()` 메소드는 한 번만 호출 가능
→두 번 호출 시 `IllegalThreadStateException` 발생
- 쓰레드를 실행시키는 메소드는 run()이 아니라 start()이다.
- `start()`는 새로운 쓰레드가 작업을 실행하는데 필요한 호출 스택(call stack)을 생성
→ `run()`호출
→ 생성된 호출스택에 `run()`이 첫 번째로 올라가게 함.
- 모든 쓰레드는 독립적인 작업 수행을 위해 각각의 호출 스택이 필요.
→ 새로운 쓰레드를 생성하고 실행시킬 때마다 새로운 호출스택 생성, 소멸 작업
- 호출 스택은 이름처럼 스택과 같이 동작하며 가장 위에 있는 메소드가 실행되고, 나머지는 대기 상태이다. 
→ 쓰레드가 둘 이상일 경우 최상위 메소드일지라도 대기상태에 있을 수 있다.

---

## Thread의 상태

- **NEW**
    - 쓰레드가 생성되고 아직 `start()`가 호출되지 않은 상태
- **RUNNABLE**
    - 실행 또는 실행 가능한 상태
- **BLOCKED**
    - 동기화 블럭에 의해서 일시정지된 상태 (lock이 풀릴 때까지 기다리는 상태)
- **WAITING, TIMED_WAITING**
    - 쓰레드의 작업이 종료되지는 않았지만 실행 가능하지 않은(unrunnable) 일시정지 상태
    - TIME_WAITING은 일시정지 시간이 지정된 경우
- **TERMINATED**
    - 쓰레드의 작업이 종료된 상태

---

## Thread 메소드

- **`sleep()`** : 일정시간동안 쓰레드를 멈춤.
- **`interrupt()`**, **`interrupted()`** : 쓰레드 작업 취소
- **`suspend()`** : 쓰레드 멈춤
- **`resume()`** : 다시 실행
- **`stop()`** : 쓰레드 종료
- **`yield()`** : 다른 쓰레드에게 양보
- **`join()`** : 다른 쓰레드의 작업을 기다림

---

## Thread의 우선순위

- 쓰레드 우선순위 관련 메소드 및 상수
- 우선순위의 범위는 1 ~ 10 이며, 숫자가 높을 수록 우선순위가 높다.

```java
void setPriority(int newPriority) // 쓰레드의 우선순위를 지정한 값으로 변경한다.
int getPriority()                 // 쓰레드의 우선순위를 반환한다.

public static final int MAX_PRIORITY  = 10   // 최대 우선순위
public static final int MIN_PRIORITY  = 1    // 최소 우선순위
public static final int NORM_PRIORITY = 5    // 보통 우선순위
```

---

## Main 쓰레드

- `main()` 메소드의 작업을 수행하는 것도 쓰레드, 이 쓰레드를 main쓰레드라 한다.
- 프로그램을 실행하면 기본적으로 하나의 쓰레드를 생성하고, 그 쓰레드가 `main()`메소드를 호출해서 작업이 수행 되는 것.
- 보통 `main()` 메소드가 수행을 마치면 프로그램이 종료되지만, `main()` 메소드가 수행을 마쳤는데 다른 쓰레드가 아직 작업 중이라면 프로그램이 종료되지 않는다.
- 메인 쓰레드 우선순위는 기본값(5)이다.
- 메인 쓰레드에서 실행된 쓰레드들은 따로 우선 순위를 지정하지 않았다면 메인쓰레드의 우선순위를 상속 받는다.

---

## 동기화

- 멀티 쓰레드 환경에서는 여러 쓰레드가 같은 프로레스 내의 자원을 공유하기 때문에 서로의 작업에 영향을 줄 수 있다.
- 이러한 일을 방지 하기 위해서 한 쓰레드가 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다. 
→ `임계영역(critical section)`과 `잠금(lock)`
- 공유데이터를 사용하는 코드 영역을 임계 영역으로 지정 후, 공유 데이터(객체)가 가지고 있는  lock을 획득한 단 하나의 쓰레드만 이 영역내의 코드를 수행할 수 있게한다.

### synchronized를 이용한 동기화

```java
public synchronized void calcSum() {
// …
}
```

- 메소드 앞에 `synchronized`를 붙이는 것
- 메소드 전체가 임계 영역으로 설정 된다.

```java
synchronized(객체의 참조변수) {
// …
}
```

- 메소드 내의 코드 일부를 임계 영역으로 설정

- 두 방법 모두 lock의 획득과 반납이 자동적으로 이루어진다 
→ 임계 영역만 설정해주면 된다.

---

## 데드락

- 교착상태는 두 개 이상의 작업이 서로 상대방의 작업이 끝나기를 기다리고 있어서 아무것도 완료되지 못하는 상태를 말한다.

### 교착상태의 조건

1. **상호배제(Mutual exclusion)** : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
2. **점유대기(Hold and wait)** : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
3. **비선점(No preemption)** : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
4. **순환대기(Circular wait)** : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
- 위 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다.
- 이중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.

## 예방

- **상호배제 조건의 제거**
    - 교착 상태는 두 개 이상의 프로세스가 공유가능한 자원을 사용할 때 발생하는 것이므로 공유 불가능한, 즉 상호 배제 조건을 제거하면 교착 상태를 해결할 수 있다.
- **점유와 대기 조건의 제거**
    - 한 프로세스에 수행되기 전에 모든 자원을 할당시키고 나서 점유하지 않을 때에는 다른 프로세스가 자원을 요구하도록 하는 방법이다. 자원 과다 사용으로 인한 효율성, 프로세스가 요구하는 자원을 파악하는 데에 대한 비용, 자원에 대한 내용을 저장 및 복원하기 위한 비용, 기아 상태, 무한대기 등의 문제점이 있다.
- **비선점 조건의 제거**
    - 비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 준다.
- **환형 대기 조건의 제거**
    - 자원 유형에 따라 순서를 매긴다.

이 해결 방법들은 자원 사용의 효율성이 떨어지고 비용이 많이 드는 문제점이 있다.
